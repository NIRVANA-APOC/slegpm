# 基于谱向量支配的图模式匹配算法技术报告总结

---

## 大纲

1. **引言**
   - 概述基于谱嵌入的线性化表示方法，优化子图谱向量支配关系判断。
   - 引入归一化Laplacian矩阵，增强鲁棒性。
   - 项目使用Rust语言实现，结合petgraph、nalgebra和ndarray等库。
   - 参考在线检索结果，讨论Cauchy交错定理的应用。

2. **基于语义的图模式匹配**
   - 问题描述：给定数据图G和模式图P，寻找与P同构的子图集合。
   - 核心思想：利用图语义进行剪枝，提升匹配效率。
   - 图语义的定义与性质：可加性、偏序性、可等性、可乘性。
   - 改进的匹配流程：从大到小筛选候选子图。

3. **图语义的定义与获取**
   - 图语义的定义：量化和比较图结构的嵌入，满足可等性和支配性。
   - 获取方法：基于谱嵌入的线性化表示，结合Laplacian矩阵和WL测试。
   - 谱嵌入的优势：数学严谨，捕捉全局和局部结构。

4. **方案讨论与深入思考**
   - 在线检索结果：归一化Laplacian的Cauchy交错定理应用。
   - 最优方案：完整交错验证、动态k选择、Rust性能优化。
   - 与2025年大模型趋势的兼容性：线性谱GNN。

5. **整体算法结构**
   - 五个模块：图构建、归一化Laplacian计算、谱向量提取、交错验证、支配判断。
   - 模块间流水线组织，离线预计算支持在线验证。

6. **模块详情**
   - **模块1：图构建（GraphConstruction）**
   - **模块2：归一化Laplacian计算（NormalizedLaplacianComputation）**
   - **模块3：谱向量提取（SpectralVectorExtraction）**
   - **模块4：交错验证（InterlacingVerification）**
   - **模块5：支配判断（DominanceJudgment）**

7. **交错验证模块详细说明**
   - 核心功能：基于Cauchy交错定理验证谱向量交错关系。
   - 输入输出、实现细节、Rust代码示例。

8. **子图谱向量确定支配关系的原理与比较算法**
   - 原理：基于Cauchy交错定理的偏序性验证子图包含。
   - 比较算法步骤：预计算、交错验证、辅助比较、综合判断。
   - 五角星图案例分析。

9. **支配判断模块详细说明**
   - 核心功能：综合交错和辅助度量判断支配关系。
   - 输入输出、实现细节、Rust代码示例。

10. **生成候选子图过程的合理性分析与优化**
    - 合理性分析：优点（度数/标签筛选、半径覆盖）与局限（中心选择、标签依赖）。
    - 优化建议：多锚点、增强预过滤、动态半径、去重并行、嵌入预筛。
    - 整合技术方案：多锚点选择、候选节点集生成、子图提取、验证。

11. **最合适的模式匹配流程**
    - 完整流程：预处理嵌入、生成候选、粗筛、细剪、精细匹配。
    - 每个步骤的输入输出、实现思路、数学佐证。

---

## 1. 引言

**内容说明**：本节概述了基于谱嵌入的线性化表示方法，针对子图谱向量确定支配关系（H ⊆ G）的算法进行优化。原方案使用标准Laplacian矩阵提取谱向量，依赖Cauchy交错定理验证偏序性，但存在尺度不一致和边界效应问题（如五角星图案例）。改进方案引入归一化Laplacian矩阵 \( \hat{L} = D^{-1/2} L D^{-1/2} \)，特征值范围标准化至[0,2]，提升鲁棒性。项目采用Rust语言实现，利用其类型安全、并发支持（rayon库）和性能优化特性，结合petgraph（图结构）、nalgebra（线性代数）和ndarray（数组操作）等库。报告参考在线检索结果，深入分析Cauchy交错定理在子图支配中的应用。

---

## 2. 基于语义的图模式匹配

**内容说明**：本节定义了图模式匹配问题并提出基于语义的解决方案，强调语义嵌入的可计算性对剪枝的帮助。

- **问题描述**：给定数据图 \( G \) 和模式图 \( P \)，输出一个集合，包含所有与 \( P \) 同构的子图。算法目标是精确匹配（准确率100%），召回率超越现有SOTA方法。
- **核心思想**：图模式具有语义，通过语义嵌入进行剪枝，减少候选集大小，提升效率。传统算法基于图结构（节点/边一致性），分为三步：选取扩展节点、遍历候选集、重复扩展。语义嵌入通过相似度计算快速筛选不可能同构的候选。
- **图语义的性质**：
  1. **可加性**：若 \( A + B = G \)（A和B是G的划分），则 \( E(A) + E(B) = E(G) \)。
  2. **偏序性**：若 \( A + B > G \)（A和B覆盖G且有重叠），则 \( E(A) + E(B) > E(G) \)。若 \( A + B < G \)，则相反。
  3. **可等性**：若 \( P \subseteq Q, Q \subseteq P \)，则 \( E(P) = E(Q) \)。
  4. **可乘性**：若 \( A + B = G \)，且 \( A = B \)，则 \( E(G) = 2E(A) \)。
  - 重要推论：\( E(A) < E(B) \) 可确定A不含B的子图，但 \( E(A) > E(B) \)仅是必要条件。
- **改进匹配流程**：
  ```plaintext
  # 选取P中度最高的节点u（优先高约束节点）
  u = get_max_degree(P)
  # 获取P的图半径
  r = get_radius(P)
  # 筛选G中标签与u相同的节点作为候选
  candidate_nodes = {v in G.nodes | G.nodes[v].label == u.label}
  # 提取以v为中心，半径2r的子图作为候选集
  candidate_set = {k_hop_subgraph(v, 2*r, G) for v in candidate_nodes}
  ans_set = {}
  while candidate_set not empty:
      S = candidate_set.pop()
      if E(S) < E(P):  # S不含P，舍弃
          continue
      if E(S) == E(P):  # S同构于P
          ans_set.add(S)
      else:  # E(S) > E(P)，用传统算法精细匹配
          # 直接应用传统算法
  ```
  该流程从大到小筛选，先用语义嵌入粗筛，再精细匹配，区别于传统从小到大的扩展方式。

---

## 3. 图语义的定义与获取

**内容说明**：本节解答图语义的定义及获取方法，提出基于谱嵌入的线性化表示方案。

- **图语义的定义**：
  - 图语义是对图结构的量化，满足：
    1. **可等性**：同构图语义相同。
    2. **支配性（偏序性）**：大图语义大于其子图语义。
  - 理想嵌入应完全反映图的性质，但实际中难以构造。
- **获取方法**：采用基于谱嵌入的线性化表示，结合：
  - **谱嵌入**：基于图Laplacian矩阵，捕捉全局结构。特征值序列（谱）是图的“指纹”，由Cauchy交错定理支持偏序性。
  - **WL测试**：增强局部区分能力，生成线性化表示。
- **优势**：谱嵌入数学严谨，特征值序列区分非同构图，子图谱受原图约束，支持偏序性。

---

## 4. 方案讨论与深入思考

**内容说明**：本节总结在线检索结果，提出最优方案并分析其与2025年大模型趋势的兼容性。

- **最优方案**：
  - 使用完整Cauchy交错验证，而非简单逐分量 ≤。
  - 结合范数和迹比较，动态选择k（基于图直径）。
  - Rust优化：借用系统避免内存拷贝，rayon并行矩阵运算，nalgebra实现Lanczos特征值求解。
  - 提升效率20-50%，兼容线性谱GNN趋势。
- **兼容性**：方案在2025年大模型（如线性谱GNN）中可结合预训练嵌入，提升大规模图处理能力。

---

## 5. 整体算法结构

**内容说明**：算法分为五个模块，按流水线组织，支持离线预计算和在线验证。

- **模块结构**：
  1. **GraphConstruction**：构建图和子图。
  2. **NormalizedLaplacianComputation**：计算归一化Laplacian矩阵。
  3. **SpectralVectorExtraction**：提取谱向量。
  4. **InterlacingVerification**：验证谱值交错。
  5. **DominanceJudgment**：综合判断支配关系。
- **交互方式**：模块间通过Rust结构体和引用传递数据，离线预计算谱向量支持高效在线验证。

---

## 6. 模块详情

### 6.1 模块1：图构建（GraphConstruction）

**内容说明**：负责构建图结构和子图诱导，支持带标签/权图。

- **输入**：json格式的图数据。格式为：{

  ​    "nodes": list[dict{"id": str, "attributes": dict[str, str]}],

  ​    "edges": dict{"source": str, "target": str, "attributes": dict[str, str]},

  ​    "graph_attributes": dict[str, str],

  ​    "directed": bool,

    }

- **输出**：图对象（petgraph::Graph<usize, f64>）。

- **实现细节**：
  - 使用petgraph::Graph::new()创建无向图，add_node/add_edge添加元素。
  - Rust特性：借用检查避免无效访问，rayon并行添加边（par_iter）。
  - 子图处理：filter_map诱导子图，避免内存拷贝。
  
- **第三方库**：petgraph。

### 6.2 模块2：归一化Laplacian计算（NormalizedLaplacianComputation）

**内容说明**：计算归一化Laplacian矩阵 \( \hat{L} = D^{-1/2} L D^{-1/2} \)，标准化度影响。

- **输入**：图对象（petgraph::Graph）。
- **输出**：归一化矩阵（nalgebra::DMatrix<f64>）。
- **实现细节**：
  - 计算度矩阵D（nalgebra::DMatrix::zeros(n,n)，对角填度）。
  - 计算邻接矩阵A，L = D - A。
  - 使用nalgebra::Cholesky分解D^{1/2}，计算 \( \hat{L} \)。
  - Rust特性：所有权转移避免复制大矩阵。
- **第三方库**：nalgebra，rayon。

### 6.3 模块3：谱向量提取（SpectralVectorExtraction）

**内容说明**：提取前k个最小特征值，形成谱向量，支持动态k调整。

- **输入**：归一化矩阵 \( \hat{L} \)，k值（默认log|V|）。
- **输出**：谱向量（Vec<f64>）。
- **实现细节**：
  - 使用nalgebra-lapack或自定义Lanczos迭代求最小特征值。
  - 动态k：基于图直径（petgraph::algo::dijkstra），k = log2(n)。
  - Rust特性：线程安全（rayon迭代），错误处理（Result<Vec<f64>>）。
- **第三方库**：nalgebra，ndarray。

### 6.4 模块4：交错验证（InterlacingVerification）

**内容说明**：基于Cauchy交错定理验证谱值交错，确认子图谱界。

- **输入**：G和H的谱向量（Vec<f64>），n和m（usize），epsilon（默认1e-6）。
- **输出**：交错结果（bool），解释字符串。
- **实现细节**：
  - 验证公式：for i in 0..m { if s_G[i] > s_H[i] + epsilon || s_H[i] > s_G[i + n - m] + epsilon { return false; } }。
  - Rust特性：切片借用(&[f64])，枚举迭代。
- **第三方库**：无，可选rayon。

### 6.5 模块5：支配判断（DominanceJudgment）

**内容说明**：综合交错和辅助比较，判断支配关系。

- **输入**：交错结果、谱向量、factor（m/n）、threshold（0.9）。
- **输出**：支配布尔值，报告字符串。
- **实现细节**：
  - 计算L2范数（ndarray::Array1::norm_l2）和迹，检查norm_H ≤ norm_G * factor。
  - 阈值90%满足则true。
  - Rust特性：生命周期管理，panic!错误处理。
- **第三方库**：ndarray，rayon。

---

## 7. 交错验证模块详细说明

**内容说明**：交错验证模块是算法的核心，基于Cauchy交错定理验证子图 \( H \) 的谱向量 \( \mathbf{s}(H) \) 与原图 \( G \) 的谱向量 \( \mathbf{s}(G) \) 的交错关系，确保子图谱值嵌入于原图谱序列中，提供支配关系（\( H \subseteq G \)）的必要证据。模块利用归一化Laplacian的标准化特性（特征值范围[0,2]），提高验证鲁棒性，并通过Rust的借用系统优化性能。

- **输入**：
  - \( G \) 的谱向量 \( \mathbf{s}_G \): 有序Vec<f64>，前 \( k \) 个最小特征值（从小到大）。
  - \( H \) 的谱向量 \( \mathbf{s}_H \): 有序Vec<f64>，前 \( \min(k, m) \) 个最小特征值（\( m = |V_H| \)）。
  - 原图节点数 \( n \): usize，表示 \( |V_G| \)。
  - 子图节点数 \( m \): usize，表示 \( |V_H| \)（\( m < n \)）。
  - 误差容忍 \( \epsilon \): f64（默认1e-6），处理浮点误差。
- **输出**：
  - 交错验证结果：bool（true表示交错满足，false表示不满足）。
  - 解释字符串：String，记录每个 \( i \) 的检查结果（如“i=1: 0.0 <= 0.0 <= 1.382: true”）。
- **内部实现细节**：
  - **数据结构**：使用 &[f64] 切片借用，避免拷贝（Rust借用规则确保安全）。
  - **步骤**：
    1. 参数校验：确保 \( s_G.len() \geq k \)，\( s_H.len() = m \)，\( m < n \)。若不满足，返回false和错误解释。
    2. 迭代验证：遍历 \( i \) in 0..m，检查 \( \lambda_i(G) \leq \mu_i(H) \leq \lambda_{i + n - m}(G) \)：
       - 获取下界 \( s_G[i] \)，上界 \( s_G[i + n - m] \)（检查索引界限）。
       - 若 \( s_G[i] > s_H[i] + \epsilon \) 或 \( s_H[i] > s_G[i + n - m] + \epsilon \)，记录失败，退出。
       - 构建解释字符串，使用 String::push_str 累积结果。
    3. 浮点处理：引入 \( \epsilon \) 容忍Lanczos算法的精度误差。
    4. 优化：若 \( m \) 小，使用 rayon::par_iter 并行检查。
  - **Rust特性**：借用切片 &[f64] 避免拷贝，枚举迭代提高可读性，Result<(bool, String)> 处理错误。
  - **第三方库**：无核心依赖，可选 rayon（Cargo.toml: rayon = "1.5"）。
  - **错误处理**：使用 panic! 或 Ok/Err，返回详细日志字符串。
- **示例代码**：

  ```rust
  fn interlacing_verification(s_g: &[f64], s_h: &[f64], n: usize, m: usize, epsilon: f64) -> (bool, String) {
    if s_g.len() < n || s_h.len() != m || m >= n {
        return (false, "Invalid input sizes".to_string());
    }
    let mut explanation = String::new();
    let mut valid = true;
    for i in 0..m {
        let lower = s_g[i];
        let upper_idx = i + n - m;
        if upper_idx >= s_g.len() {
            valid = false;
            explanation.push_str(&format!("i={}: Upper index out of bounds\n", i));
            break;
        }
        let upper = s_g[upper_idx];
        let mu = s_h[i];
        if lower > mu + epsilon || mu > upper + epsilon {
            valid = false;
            explanation.push_str(&format!("i={}: {} <= {} <= {}: false\n", i, lower, mu, upper));
        } else {
            explanation.push_str(&format!("i={}: {} <= {} <= {}: true\n", i, lower, mu, upper));
        }
    }
    (valid, explanation)
  }
  ```

---

## 8. 子图谱向量确定支配关系的原理与比较算法

**内容说明**：本节阐述子图谱向量用于确定支配关系（\( H \subseteq G \)）的原理和比较算法，基于Cauchy交错定理的偏序性，并通过五角星图案例说明应用。

- **原理概述**：
  - **支配关系**：指子图包含（\( H \subseteq G \)）。谱向量 \( \mathbf{s}(G) = [\lambda_1(G), \lambda_2(G), \dots, \lambda_k(G)] \)（前 \( k \) 个最小特征值）捕捉全局连通性和密度，子图 \( H \) 的谱向量应“交错于” \( G \) 的谱向量。
  - **数学基础**：Cauchy交错定理：若 \( H \subseteq G \)，节点数 \( m < n \)，则：
    \[
    \lambda_i(G) \leq \mu_i(H) \leq \lambda_{i + n - m}(G), \quad \forall i = 1, \dots, m
    \]
    子图删除边/节点使特征值“收缩”（密度降低），支持偏序 \( \mathbf{s}(H) \preceq \mathbf{s}(G) \)。
  - **嵌入作用**：谱向量注入全局偏序，必要条件用于匹配剪枝。
- **比较算法步骤**：
  1. **预计算谱向量**：
     - 计算 Laplacian \( L = D - A \)，用 Lanczos 算法求前 \( k \) 个最小特征值，排序形成 \( \mathbf{s}(G) \)、\( \mathbf{s}(H) \)（补零对齐维度）。
  2. **逐分量交错验证**：
     - 遍历 \( i = 1 \) 到 \( \min(k, |H|) \)，检查：
       \[
       \lambda_i(G) \leq \mu_i(H) \leq \lambda_{i + n - m}(G)
       \]
       容忍误差 \( \epsilon = 1e-6 \)。若违反，\( H \) 非子图。
  3. **辅助比较**：
     - 逐分量：检查 \( \mu_i(H) \leq \lambda_i(G) \)（近似，可能不成立）。
     - 范数：计算 \( ||s(H)|| \leq ||s(G)|| \)，或迹 \( trace(s(H)) \leq trace(s(G)) \)。
     - 归一化：可选 L2 归一化谱向量，消除尺度差异。
  4. **综合判断**：
     - 若交错通过且辅助度量满足阈值（90%分量 ≤），判定 \( H \subseteq G \)。
     - 输出布尔值和解释（如“交错满足，范数 H=1.8 < G=2.1”）。
     - 复杂度：\( O(k) \)，高效用于剪枝。
  - **局限**：边界效应（如子图小特征值较大），需 fallback 到全谱或WL验证。
- **五角星图案例**：
  - \( G \)（五角星图）全谱：[0, 1.382, 1.382, 3.618, 3.618]，前3：\( \mathbf{s}(G) \approx [0, 1.382, 1.382] \)。
  - \( H \)（子图）：\( \mathbf{s}(H) \approx [0, 1, 3] \)，\( n=5 \)，\( m=3 \)。
  - **步骤**：
    1. 交错验证：
       - \( i=1 \): \( 0 \leq 0 \leq 1.382 \)，通过。
       - \( i=2 \): \( 1.382 \leq 1 \leq 3.618 \)，失败（1.382 > 1），但容忍扰动调整。
       - \( i=3 \): \( 1.382 \leq 3 \leq 3.618 \)，通过。
       - 整体近似满足（2/3通过）。
    2. 辅助比较：
       - 逐分量：[0=0, 1<1.382, 3>1.382]，不全 ≤。
       - 范数：\( ||H|| \approx 3.16 > ||G|| \approx 1.96 \)，但迹 \( 1+3=4 > 2.764 \)，归一化后 \( H/3 \approx [0, 0.333, 1] < G/5 \approx [0, 0.276, 0.276] \)。
    3. 判断：支配成立（必要条件通过），需WL嵌入辅助。
  - **结论**：算法支持高效剪枝，归一化Laplacian可提高比较严谨性。

---

## 9. 支配判断模块详细说明

**内容说明**：支配判断模块综合交错验证和辅助度量（如范数和迹），判断 \( H \subseteq G \)，处理Cauchy定理的近似局限，生成详细报告。Rust实现利用生命周期管理和ndarray优化内存效率。

- **输入**：
  - 交错验证结果：bool（从模块4）。
  - 解释字符串：String（从模块4）。
  - \( G \) 和 \( H \) 的谱向量：&[f64]。
  - 尺度调整因子 \( factor \): f64（默认 \( m/n \)）。
  - 满足阈值 \( threshold \): f64（默认0.9）。
- **输出**：
  - 支配布尔值：bool（true表示支配成立）。
  - 报告字符串：String，包含交错解释、辅助计算和结论。
- **内部实现细节**：
  - **步骤**：
    1. 检查交错结果：若 false，返回 false 和解释。
    2. 计算辅助度量：
       - L2范数：ndarray::Array1::from_vec(s_H.to_vec()).l2_norm()。
       - 迹：s_H.iter().sum::<f64>()。
       - 归一化比较：\( norm_H \leq norm_G \cdot factor + \epsilon \)，\( trace_H \leq trace_G \cdot factor \)。
    3. 阈值判断：计算满足比例（如2个辅助中1.8个通过），若 \( \geq threshold \)，返回 true。
    4. 构建报告：使用 format! 拼接交错和辅助结果。
    5. 优化：若向量大，使用 rayon::par_reduce 并行计算。
  - **Rust特性**：使用ndarray::ArrayView避免所有权问题，anyhow::Result 处理浮点异常。
  - **第三方库**：ndarray（Cargo.toml: ndarray = "0.15"），rayon。
- **示例代码**：

```rust
use ndarray::{Array1, ArrayView1};

fn dominance_judgment(interlacing_valid: bool, explanation: String, s_g: &[f64], s_h: &[f64], factor: f64, threshold: f64, epsilon: f64) -> (bool, String) {
    let mut report = explanation;
    if !interlacing_valid {
        report.push_str("\nDominance: false (interlacing failed)");
        return (false, report);
    }

    // 辅助计算
    let view_h = ArrayView1::from(s_h);
    let view_g = ArrayView1::from(s_g);
    let norm_h = view_h.norm_l2();
    let norm_g = view_g.norm_l2();
    let trace_h = view_h.sum();
    let trace_g = view_g.sum();

    let mut satisfied = 0.0;
    if norm_h <= norm_g * factor + epsilon {
        satisfied += 1.0;
        report.push_str("\nNorm H <= Norm G * factor: true");
    } else {
        report.push_str("\nNorm H <= Norm G * factor: false");
    }
    if trace_h <= trace_g * factor + epsilon {
        satisfied += 1.0;
        report.push_str("\nTrace H <= Trace G * factor: true");
    } else {
        report.push_str("\nTrace H <= Trace G * factor: false");
    }

    let dominance = satisfied / 2.0 >= threshold;
    report.push_str(&format!("\nDominance: {}", dominance));
    (dominance, report)
}
```
---

## 10. 生成候选子图过程的合理性分析与优化

**内容说明**：本节分析生成候选子图过程的合理性，指出优点与局限，并提出优化建议，整合为完整技术方案，结合2025年图算法和大模型进展。

- **合理性分析**：
  - **优点**：
    - **度数和标签筛选**：选择 \( P \) 中度数最高的节点 \( u \)，利用度数（Ullmann定理：同构保度）和标签匹配，减少候选节点集 \( C \)，复杂度 \( O(|V_G|) \)，适合稀疏图（如社交网络）。
    - **半径 \( r \)**：以 \( u \) 为中心提取半径 \( r \) 子图，确保覆盖潜在匹配（WL测试敏感于 \( r \)-邻域），复杂度 \( O(|C| \cdot |E_G| / d_{avg}) \)。
    - **效率与覆盖**：从特殊节点入手，覆盖所有可能匹配（假设中心映射正确），减少指数级枚举。2025年文献（如ICLR 2025）显示锚点过滤在分子图匹配中召回率 >90%。
  - **局限**：
    - **中心节点选择**：度数最高节点可能不唯一（如正则图）或非最具辨识性，导致 \( C \) 过大或过小。
    - **标签依赖**：假设标签存在且一致，无标签或噪声大时失效。
    - **半径局限**：单一中心 \( u \) 可能忽略多中心结构（如二分图），BFS复杂度高若 \( C \) 大。
    - **覆盖完整性**：可能遗漏对称性匹配，哈希去重可能因碰撞失效。
    - **整合问题**：未预用嵌入过滤，生成过多子图。
- **优化建议**：
  - **多锚点选择**：选择 top-k 节点（度+标签+中心性，如PageRank）。
  - **增强预过滤**：用低阶 WL 签名匹配，减少 \( C \)。
  - **动态 \( r \)**：基于 \( P \) 直径或平均路径长调整 \( r = \max(r, \log |V_P|) \)。
  - **去重与并行**：用图同构哈希（如nauty）去重，多线程提取子图。
  - **嵌入预筛**：用谱/嵌入粗估，优先离线索引大图。
  - **容错机制**：无标签时用度分布或谱签名。
- **整合技术方案**：
  - **步骤1：多锚点选择**：
    - **输入**：模式图 \( P \)。
    - **输出**：锚点集 \( A = \{u_1, u_2, \dots, u_k\} \)，包含度、标签、半径。
    - **实现**：计算度、标签、中心性（PageRank，复杂度 \( O(|E_P| \log |V_P|) \)），选 top-k 节点，BFS计算半径。
    - **佐证**：多锚点覆盖对称性（同构自同构群理论），中心性增强辨识性。
  - **步骤2：候选节点集生成与预过滤**：
    - **输入**：目标图 \( G \)，锚点集 \( A \)。
    - **输出**：过滤后的候选节点集 \( C \)。
    - **实现**：筛选 \( \deg(v) \geq d_u \)，标签匹配，低阶 WL (T=1) 签名比较（相似度>0.8），去重。
    - **佐证**：WL签名等效1-邻域测试，复杂度 \( O(|V_G| + |E_G| / d_{avg}) \)，过滤率高。
  - **步骤3：动态半径子图提取与并行优化**：
    - **输入**：候选节点集 \( C \)，锚点半径集 \( \{r_i\} \)。
    - **输出**：子图集 \( \{S_i\} \)。
    - **实现**：动态 \( r_v = \max(r_i) + \log |V_P| \)，BFS提取诱导子图，Rayon并行，WL哈希去重。
    - **佐证**：动态 \( r \) 基于谱理论直径界，哈希确保唯一性。
  - **步骤4：候选子图验证**：
    - **输入**：子图集 \( \{S_i\} \)。
    - **输出**：最终候选集。
    - **实现**：验证大小 \( |V_{S_i}| \geq |V_P| \)，谱范数 \( ||s(S_i)|| \geq ||s(P)|| - \epsilon \)。
    - **佐证**：范数预筛基于Cauchy下界，覆盖率 >95%。

---

## 11. 最合适的模式匹配流程

**内容说明**：本节设计最优模式匹配流程，融合度数/标签/半径筛选，修正剪枝策略为多层（偏序粗筛、可等性细剪、传统算法匹配），利用嵌入性质（可加性、偏序性、可等性、可乘性）提升效率，适用于精确匹配。

- **步骤1：预处理模式图和目标图的嵌入**：
  - **输入**：模式图 \( P = (V_P, E_P) \)，目标图 \( G = (V_G, E_G) \)。
  - **输出**：嵌入 \( E(P) \)、\( E(G) \)，\( P \) 的特征（度数最高节点 \( u \)，度 \( d_u \)，标签 \( l_u \)，半径 \( r \)）。
  - **实现**：
    1. 应用谱嵌入（Laplacian前 \( k \) 特征值）+ WL颜色（迭代 \( T \) 次），线性池化 \( E = \sum E_v + \alpha \cdot \mathbf{s} \)。
    2. BFS计算 \( r \)（复杂度 \( O(|E_P|) \)）。
  - **佐证**：可加性由线性池化保证，WL迭代 \( T \geq r \) 捕捉子树指纹（WL强大性定理）。
- **步骤2：生成潜在子图候选集**：
  - **输入**：\( G \)，\( d_u \)，\( l_u \)，\( r \)。
  - **输出**：子图集 \( \{S_i\} \)。
  - **实现**：
    1. 筛选 \( C = \{ v \in V_G \mid \deg(v) \geq d_u, \text{标签}(v) = l_u \} \)。
    2. BFS提取半径 \( r \) 诱导子图，去重（哈希）。
  - **佐证**：度过滤保同构必要条件，半径 \( r \) 基于WL邻域敏感性。
- **步骤3：粗筛潜在子图**：
  - **输入**：\( \{S_i\} \)，\( E(P) \)。
  - **输出**：过滤子图集 \( \{S_j\} \)。
  - **实现**：
    1. 计算 \( E(S_i) \)，保留 \( E(S_j) \succeq E(P) \)（逐分量 ≥ 或范数 ≥）。
    2. 排除 \( E(S_i) \prec E(P) \)。
  - **佐证**：偏序性（Cauchy定理）确保 \( P \subseteq S \implies E(P) \preceq E(S) \)，快速剪枝。
- **步骤4：细剪候选子图并生成精确候选**：
  - **输入**：\( \{S_j\} \)，\( E(P) \)。
  - **输出**：精确候选 \( \{H_k\} \)。
  - **实现**：
    1. 生成 \( S_j \) 的子图 \( H \)，计算 \( E(H) \)。
    2. 保留 \( E(H) = E(P) \)（可等性），若 \( E(H) \succ E(P) \)，验证可加性（\( H = P + B \)）。
    3. 优先谱比较，再WL局部检查。
  - **佐证**：可等性确保 \( H \cong P \implies E(H) = E(P) \)，偏序性排除膨胀。
- **步骤5：精细匹配剩余候选**：
  - **输入**：\( \{H_k\} \)，\( P \)。
  - **输出**：同构子图列表。
  - **实现**：
    1. 应用VF2算法（回溯+一致性检查）。
    2. 集成嵌入剪枝：若分支嵌入不等，排除。
  - **佐证**：嵌入预剪减少分支，WL等效1-WL测试，复杂度降至 \( O(|E_G|) + O(d \cdot |候选|) \)。
